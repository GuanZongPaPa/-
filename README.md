## 象棋中马的遍历

**一、数据结构：**
* 图的节点(二维数组存储N*N个节点)：
```
typedef struct Node {
	int c;//表示是否走过（1：走过，0：未走过）
	int n;//初始化为0x00，每一个二进制位代表一个方向是否已经走过
}node;
```

* 自定义程序栈（存储走地图的路线）：
```
typedef struct Stack {
	int x;
	int y;
	Stack* next;
}stack;
```
* 马的数据结构：
```
typedef struct Horse {
	int x;
	int y;
}horse;
```
* 地图数组：
```
node Map[N][N];
```

**二、算法简述：**

1.（概述）马在象棋中的行走，求解它的一次性遍历路线，一开始看到题目我们脑海中应该至少有两个概念浮现：**栈和回溯**。其实这个题目跟我们在数据结构中学过的“迷宫求解”问题
  有异曲同工之妙。本质就是依靠计算机强大的计算能力，不断地猜测怎么走，把走过的路程入栈，发现走不通进入死胡同再退栈重新选择方向，直到找到那个走出的方法。

2.（分析）我们对解决问题已经想清楚了大概流程，我们就要思考控制马每一步行走的具体细节。马跟迷宫还是有所不同，它有八个方向可以行走，那么当马要走出一步，我们得考虑几个小问题：
* （1）是否越出地图边界？
* （2）是否会走到已经走过的地方？
* （3）是否会重复进入以前走过，但是无法走通的方向？
* （4）如果已经确定了几个可以走的方向，我们选择哪一个？
* （5）选择好了方向，我们应该做哪些修改？
* （6）如果发现所有方向都无法行走，又应该怎么办？
而解决以上的问题就是我们控制马行走的关键。

3.（解决）针以上问题我们设计出行走方案：
>建立EachFoot()函数，它控制马的行走，具体功能依次有：
* （1）地图越界检查->将下一步不越界的方向选择出来；
* （2）检查地图节点中的成员c->如果c=1表示被占用，不能前进到此位置，把所有c=0的方向选择出来；
* （3）检查地图节点中的成员n->把n看为8位2进制数，每一位代表一个方向以前是否已经走过，把所有为0的方向选择出来；
* （4）我们在函数的开始用了dir数组，dir[i]记录的就是方向i所到达的位置点**的所有出口数**，也就是下一步的位置点有几个出口->选择其中出口数最小的那一个（这就是选择最可能的方案，局部最优）
* （5）选择好了方向我们就改变地图、栈和马的状态->地图的c，n变量修改；入栈；改变马的状态；
* （6）如果没有合适的方向，那么很容易想到退栈，可是别忘了我们仍然还要改变地图和马的状态->退栈；地图点c，n清零；马退回到上一个栈点；

**有了思路清晰的算法，我们建立相应的辅助功能函数和主函数就大功告成了！**
